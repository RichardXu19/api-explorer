<h2>Approval Service API Specification</h2>

<h3>What is the Approval Service REST API?</h3>

<p>The approval service provides features for managing and tracking the human approval tasks associated with a service process/artifact in a provider realm. It also provides a record of the approval process when it completes.</p>

<p>The goal of the approval service is to provide a generic approval mechanism that any provider can use for any artifact, such as  as a service or  a resource action (which follows its own provider specified approval process).</p>

<p>Approval is agnostic to the business artifact it is attached to. There is no representation of the artifact within the approval service. The provider (client of the approval service) stores an identifier of an approval to manage the approvals associated with their artifact.</p>

<h3>Typical Use Cases</h3>

<p>You can use the approval service REST API to implement approval policies for your service or resource action.  You can:</p>

<ul>
<li>Define multiple approval levels in which actions must be approved.</li>
<li>Define approval policies that determine how an artifact is approved.</li>
<li>Query information about the state of specified approvals and the values of data fields in schemas associated with the service or resource action.</li>
</ul>

<h3>Key Concepts</h3>

<h4>Approval Level</h4>

<p>A level of approval that you define for your service.  For each level, you can specify approval criteria.</p>

<h4>Approval Modes</h4>

<p>Each level supports two modes of approval:</p>

<ul>
<li><strong>ANY</strong> - If any ONE of the users approves, the approval step is complete and the process moves to the next step; for example, from Level 1 to Level 2. After one approver has approved, the remaining approvers are not allowed to approve that level.</li>
<li><strong>ALL</strong> - All the approvers for the level need to approve. Each approver is assigned a workitem. The approval flow can only move on to the next step after ALL the approvers have approved.</li>
</ul>

<h4>Criteria</h4>

<p>Approval criteria are specified in a JSON string of a <code>com.vmware.vcac.platform.content.criteria.Clause</code> object:</p>

<ul>
<li><p>Criteria should be set up based on the context that is defined by the corresponding <code>com.vmware.vcac.core.approvals.domain.policy.ApprovalPolicyType##getClassId()</code> and <code>com.vmware.vcac.core.approvals.domain.policy.ApprovalPolicyType##getTypeFilter()</code>.</p></li>
<li><p>The properties used in the criteria expression must be those of the client side object identified by the <code>classId</code> and <code>typeFilter</code>.</p></li>
</ul>

<p>The <code>CatalogItemRequest</code> client object provides an example of how criteria are specified. A <code>CatalogItemRequest</code> has a criteria expression based on Request fields such as <code>RequestedBy</code>, <code>CatalogItem</code>, and so on, which are direct properties of the <code>CatalogItemRequest</code> class.</p>

<h3>How the Approval Service Works</h3>

<h4>Overall High Level Flow</h4>

<p>The approval process involves a simple chain of approval steps:</p>

<ol>
<li>Currently, the approval service supports only a single series of approval steps.</li>
<li>Each step in the sequence can contain one or more users.</li>
<li>Approval flows from level1 to level2 to level3, and so on. The approvers in level2 do not receive an  approval request until level1 is approved, and so on for other steps in the series.</li>
<li>If approvers in ANY level reject the request, the whole approval is rejected. This essentially short circuits the approval process.</li>
<li>When the final approval step is approved, the Approval instance goes into the APPROVED state.</li>
</ol>

<h4>Notes About Approval Level</h4>

<ol>
<li>These are referred to as Level N Approval. Each step is activated in sequence, i.e., Level1 Approval is active first, and after it is done, Level2 Approval is active, and so on.</li>
<li>The users in an approval step can be defined (during approval policy creation/definition) using three different methods, by referring to:
<ul>
<li>One or more actual users (hard coding the user ID).</li>
<li>One or more AD groups (static) and dynamic groups (composed of multiple AD groups and actual users).</li>
<li>The users from contextual data such as $request.owner or $request.owner.manager, and so on.</li>
</ul></li>
<li>When a step is active, the users in that step are resolved, i.e., groups are expanded and contextual data expression is evaluated. The users in a step are not materialized until that step is active.</li>
<li>All the users within the step are notified of the pending approval.</li>
<li>If one of those users reject it, the Approval is short circuited and goes into the  REJECTED state.</li>
<li>A level supports two modes of approval:
<ul>
<li><strong>ANY</strong> - if any ONE of the users approves, then after the approval step is complete, the the process moves to the next step; for example, from Level1 to Level2. After one approver has approved, the remaining approvers are not allowed to approve that level.</li>
<li><strong>ALL</strong> - All the approvers resolved in this level need to approve. Each approver is assigned a workitem. The approval flow can only move on to the next step after ALL the approvers have approved.</li>
</ul></li>
</ol>

<h4>Notes About Criteria Associated with a Level</h4>

<ol>
<li>Each level has its own criteria that triggers approval from that level.</li>
<li>Criteria of every level will be evaluated in sequence.</li>
<li>Criteria is essentially a JSON string of a <code>com.vmware.vcac.platform.content.criteria.Clause</code> object.</li>
<li>Criteria should be set up based on the context which is defined by the corresponding <code>com.vmware.vcac.core.approvals.domain.policy.ApprovalPolicyType##getClassId()</code> and <code>com.vmware.vcac.core.approvals.domain.policy.ApprovalPolicyType##getTypeFilter()</code></li>
<li>The properties used in the criteria expression must be those of the client-side object identified by the <code>classId</code> and <code>typeFilter</code>. An example is the <code>CatalogItemRequest</code> client object, whose criteria expression is based on Request fields such as <code>RequestedBy</code>, <code>CatalogItem</code>, and so on, which are direct properties of the <code>CatalogItemRequest</code> class.</li>
<li>The list of concrete Clauses are:
<ul>
<li><code>com.vmware.vcac.platform.content.criteria.AndClause</code></li>
<li><code>com.vmware.vcac.platform.content.criteria.OrClause</code></li>
<li><code>com.vmware.vcac.platform.content.criteria.NotClause</code></li>
<li><code>com.vmware.vcac.platform.content.criteria.ConstantClause</code></li>
<li><code>com.vmware.vcac.platform.content.criteria.Expression</code></li>
<li><code>com.vmware.vcac.platform.content.criteria.WrapperClause</code></li>
</ul></li>
</ol>
